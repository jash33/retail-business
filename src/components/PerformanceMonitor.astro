---
/**
 * Performance Monitor Component
 *
 * Monitors Core Web Vitals and performance metrics, reporting them
 * to Google Analytics when consent is given.
 *
 * Metrics tracked:
 * - LCP (Largest Contentful Paint)
 * - FID (First Input Delay) / INP (Interaction to Next Paint)
 * - CLS (Cumulative Layout Shift)
 * - FCP (First Contentful Paint)
 * - TTFB (Time to First Byte)
 *
 * @example
 * ```astro
 * ---
 * import PerformanceMonitor from '../components/PerformanceMonitor.astro';
 * ---
 * <PerformanceMonitor />
 * ```
 */

interface Props {
  /** Enable debug logging */
  debug?: boolean;
  /** Report to Google Analytics */
  reportToGA?: boolean;
}

const {
  debug = import.meta.env.DEV,
  reportToGA = true,
} = Astro.props;
---

<script is:inline define:vars={{ debug, reportToGA }}>
  // Performance monitoring using web-vitals patterns
  (function() {
    'use strict';

    // Thresholds for Core Web Vitals (good/needs-improvement/poor)
    const THRESHOLDS = {
      LCP: [2500, 4000],
      FID: [100, 300],
      CLS: [0.1, 0.25],
      FCP: [1800, 3000],
      TTFB: [800, 1800],
      INP: [200, 500],
    };

    /**
     * Get rating for a metric value
     */
    function getRating(name, value) {
      const threshold = THRESHOLDS[name];
      if (!threshold) return 'unknown';
      if (value <= threshold[0]) return 'good';
      if (value <= threshold[1]) return 'needs-improvement';
      return 'poor';
    }

    /**
     * Report metric to GA4 (if enabled and consent given)
     */
    function reportMetric(name, value, rating) {
      if (debug) {
        console.log(`[Performance] ${name}: ${value.toFixed(2)} (${rating})`);
      }

      if (reportToGA && typeof window.gtag === 'function') {
        // Only report if analytics consent is given
        // The gtag function will handle consent internally
        window.gtag('event', 'web_vitals', {
          event_category: 'Web Vitals',
          event_label: name,
          value: Math.round(value),
          metric_name: name,
          metric_value: value,
          metric_rating: rating,
          non_interaction: true,
        });
      }
    }

    /**
     * Observe Largest Contentful Paint (LCP)
     */
    function observeLCP() {
      if (!('PerformanceObserver' in window)) return;

      try {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          const lastEntry = entries[entries.length - 1];
          const value = lastEntry.startTime;
          reportMetric('LCP', value, getRating('LCP', value));
        });

        observer.observe({ type: 'largest-contentful-paint', buffered: true });
      } catch (e) {
        if (debug) console.warn('[Performance] LCP observation not supported');
      }
    }

    /**
     * Observe First Input Delay (FID)
     */
    function observeFID() {
      if (!('PerformanceObserver' in window)) return;

      try {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          entries.forEach((entry) => {
            const value = entry.processingStart - entry.startTime;
            reportMetric('FID', value, getRating('FID', value));
          });
        });

        observer.observe({ type: 'first-input', buffered: true });
      } catch (e) {
        if (debug) console.warn('[Performance] FID observation not supported');
      }
    }

    /**
     * Observe Cumulative Layout Shift (CLS)
     */
    function observeCLS() {
      if (!('PerformanceObserver' in window)) return;

      let clsValue = 0;
      let clsEntries = [];

      try {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();

          entries.forEach((entry) => {
            // Only count layout shifts without recent user input
            if (!entry.hadRecentInput) {
              clsValue += entry.value;
              clsEntries.push(entry);
            }
          });
        });

        observer.observe({ type: 'layout-shift', buffered: true });

        // Report final CLS on page hide
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden' && clsEntries.length > 0) {
            reportMetric('CLS', clsValue, getRating('CLS', clsValue));
          }
        });
      } catch (e) {
        if (debug) console.warn('[Performance] CLS observation not supported');
      }
    }

    /**
     * Observe First Contentful Paint (FCP)
     */
    function observeFCP() {
      if (!('PerformanceObserver' in window)) return;

      try {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();
          entries.forEach((entry) => {
            if (entry.name === 'first-contentful-paint') {
              const value = entry.startTime;
              reportMetric('FCP', value, getRating('FCP', value));
            }
          });
        });

        observer.observe({ type: 'paint', buffered: true });
      } catch (e) {
        if (debug) console.warn('[Performance] FCP observation not supported');
      }
    }

    /**
     * Measure Time to First Byte (TTFB)
     */
    function measureTTFB() {
      if (!('performance' in window) || !performance.getEntriesByType) return;

      try {
        const navEntry = performance.getEntriesByType('navigation')[0];
        if (navEntry) {
          const value = navEntry.responseStart - navEntry.requestStart;
          reportMetric('TTFB', value, getRating('TTFB', value));
        }
      } catch (e) {
        if (debug) console.warn('[Performance] TTFB measurement failed');
      }
    }

    /**
     * Observe Interaction to Next Paint (INP) - replaces FID in Core Web Vitals
     */
    function observeINP() {
      if (!('PerformanceObserver' in window)) return;

      const interactions = [];

      try {
        const observer = new PerformanceObserver((entryList) => {
          const entries = entryList.getEntries();

          entries.forEach((entry) => {
            // INP considers all interactions, not just first input
            if (entry.interactionId) {
              interactions.push(entry.duration);
            }
          });
        });

        observer.observe({ type: 'event', buffered: true, durationThreshold: 16 });

        // Report INP on page hide (p98 of all interactions)
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'hidden' && interactions.length > 0) {
            // Calculate 98th percentile (p98) of interactions
            interactions.sort((a, b) => a - b);
            const p98Index = Math.ceil(interactions.length * 0.98) - 1;
            const inpValue = interactions[p98Index] || interactions[interactions.length - 1];
            reportMetric('INP', inpValue, getRating('INP', inpValue));
          }
        });
      } catch (e) {
        if (debug) console.warn('[Performance] INP observation not supported');
      }
    }

    /**
     * Initialize all performance observers
     */
    function init() {
      // Wait for the page to be fully loaded
      if (document.readyState === 'complete') {
        startObserving();
      } else {
        window.addEventListener('load', startObserving);
      }
    }

    function startObserving() {
      // Use requestIdleCallback or setTimeout to avoid blocking
      const scheduleObserver = window.requestIdleCallback || ((cb) => setTimeout(cb, 1));

      scheduleObserver(() => {
        observeLCP();
        observeFID();
        observeCLS();
        observeFCP();
        observeINP();
        measureTTFB();

        if (debug) {
          console.log('[Performance] Core Web Vitals monitoring initialized');
        }
      });
    }

    // Initialize
    init();
  })();
</script>
